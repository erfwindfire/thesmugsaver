import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '..');

// Read the processed articles text file
// Place processed-articles.txt in the project root before running
const inputPath = join(rootDir, 'processed-articles.txt');
const outputPath = join(rootDir, 'lib', 'articles.ts');

console.log('Reading:', inputPath);
const raw = readFileSync(inputPath, 'utf8');

// Parse articles from the ---ARTICLE--- delimited format
function parseArticles(text) {
  const blocks = text.split(/---ARTICLE---|---PAGE---/).filter(b => b.trim());
  const articles = [];

  for (const block of blocks) {
    const lines = block.trim().split('\n');
    const meta = {};
    let bodyStartIndex = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith('SLUG:')) {
        meta.slug = line.replace('SLUG:', '').trim();
      } else if (line.startsWith('CATEGORY:')) {
        meta.category = line.replace('CATEGORY:', '').trim();
      } else if (line.startsWith('TITLE:')) {
        meta.title = line.replace('TITLE:', '').trim();
      } else if (line.startsWith('EXCERPT:')) {
        meta.excerpt = line.replace('EXCERPT:', '').trim();
      } else if (line.startsWith('READING_TIME:')) {
        meta.readingTime = parseInt(line.replace('READING_TIME:', '').trim()) || 5;
      } else if (line.startsWith('META_TITLE:')) {
        meta.metaTitle = line.replace('META_TITLE:', '').trim();
      } else if (line.startsWith('META_DESCRIPTION:')) {
        meta.metaDescription = line.replace('META_DESCRIPTION:', '').trim();
      } else if (!line.startsWith('SLUG:') && !line.startsWith('CATEGORY:') &&
                 !line.startsWith('TITLE:') && !line.startsWith('EXCERPT:') &&
                 !line.startsWith('READING_TIME:') && !line.startsWith('META_TITLE:') &&
                 !line.startsWith('META_DESCRIPTION:') && line.trim() !== '') {
        bodyStartIndex = i;
        break;
      }
    }

    if (!meta.slug || !meta.title) continue;

    const bodyLines = lines.slice(bodyStartIndex);
    let body = bodyLines.join('\n').trim();

    // Convert markdown-style to basic HTML if needed
    body = body
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/^- (.+)$/gm, '<li>$1</li>')
      .replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

    // Wrap consecutive <li> items in <ul>
    body = body.replace(/(<li>.*<\/li>\n?)+/gs, (match) => `<ul>${match}</ul>`);

    // Wrap bare text paragraphs
    const paragraphed = body.split('\n\n').map(p => {
      p = p.trim();
      if (!p) return '';
      if (p.startsWith('<h') || p.startsWith('<ul') || p.startsWith('<ol') ||
          p.startsWith('<table') || p.startsWith('<div') || p.startsWith('<p')) {
        return p;
      }
      return `<p>${p}</p>`;
    }).filter(Boolean).join('\n');

    body = paragraphed;

    // Generate meta title if not present
    if (!meta.metaTitle) {
      meta.metaTitle = meta.title.length <= 55
        ? `${meta.title} | The Smug Saver`
        : meta.title.substring(0, 52) + '... | The Smug Saver';
    }

    // Generate meta description if not present
    if (!meta.metaDescription) {
      meta.metaDescription = meta.excerpt
        ? meta.excerpt.substring(0, 155)
        : `${meta.title} - expert money-saving tips and advice from The Smug Saver.`;
    }

    // Calculate word count
    const wordCount = body.replace(/<[^>]+>/g, ' ').split(/\s+/).filter(Boolean).length;
    if (!meta.readingTime) {
      meta.readingTime = Math.max(1, Math.round(wordCount / 200));
    }

    articles.push({
      slug: meta.slug,
      title: meta.title,
      category: meta.category || 'everyday-hacks',
      excerpt: meta.excerpt || '',
      body,
      author: 'The Smug Saver',
      datePublished: '2026-02-19',
      dateModified: '2026-02-19',
      readingTime: meta.readingTime,
      metaTitle: meta.metaTitle,
      metaDescription: meta.metaDescription,
      wordCount,
    });
  }

  return articles;
}

const articles = parseArticles(raw);
console.log(`Parsed ${articles.length} articles`);

// Generate TypeScript file
function escapeTemplate(str) {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\${/g, '\\${');
}

const tsContent = `// AUTO-GENERATED by scripts/generate-articles.mjs
// Do not edit manually - regenerate from processed-articles.txt

export interface Article {
  slug: string;
  title: string;
  category: string;
  excerpt: string;
  body: string;
  author: string;
  datePublished: string;
  dateModified: string;
  readingTime: number;
  metaTitle: string;
  metaDescription: string;
  wordCount: number;
}

export const articles: Article[] = [
${articles.map(a => `  {
    slug: ${JSON.stringify(a.slug)},
    title: ${JSON.stringify(a.title)},
    category: ${JSON.stringify(a.category)},
    excerpt: ${JSON.stringify(a.excerpt)},
    body: \`${escapeTemplate(a.body)}\`,
    author: ${JSON.stringify(a.author)},
    datePublished: ${JSON.stringify(a.datePublished)},
    dateModified: ${JSON.stringify(a.dateModified)},
    readingTime: ${a.readingTime},
    metaTitle: ${JSON.stringify(a.metaTitle)},
    metaDescription: ${JSON.stringify(a.metaDescription)},
    wordCount: ${a.wordCount},
  }`).join(',\n')}
];

// Helper functions
export function getArticleBySlug(slug: string): Article | undefined {
  return articles.find(a => a.slug === slug);
}

export function getArticlesByCategory(category: string): Article[] {
  return articles.filter(a => a.category === category);
}

export function getAllCategories(): string[] {
  return [...new Set(articles.map(a => a.category))];
}

export function getRecentArticles(count = 6): Article[] {
  return articles.slice(0, count);
}
`;

writeFileSync(outputPath, tsContent, 'utf8');
console.log('Written to:', outputPath);
console.log('Article count:', articles.length);

// Print summary
const byCategory = {};
for (const a of articles) {
  byCategory[a.category] = (byCategory[a.category] || 0) + 1;
}
console.log('\nBy category:');
for (const [cat, count] of Object.entries(byCategory).sort()) {
  console.log(` ${cat}: ${count}`);
}

const thin = articles.filter(a => a.wordCount < 1500);
if (thin.length > 0) {
  console.log('\nWARNING - articles under 1500 words:');
  for (const a of thin) {
    console.log(` ${a.slug}: ${a.wordCount} words`);
  }
}
